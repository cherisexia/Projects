# -*- coding: utf-8 -*-
"""
Created on Sat Nov 27 11:06:41 2021

@author: XPS
"""

import numpy as np
import matplotlib.pyplot as plt
import copy
import networkx as nx
import random
import matplotlib.animation as animation
from IPython.display import HTML,display
from itertools import combinations
from network_functions import *
from attributes import *
import timeit
import igraph as ig

vaccination = 0 # Choose whether to get fully vaccinated or not
init_net = 0 # Choose whether to plot the initial network (0/1)
latent_incub_plot = 0 # Choose whether to plot the distributions of the latent annd incubation periods (0/1)

# Simulation of our network

# Start timing from building the network
t_start = timeit.default_timer()


if Network_type == 'Villages':
    n_villages = len(pop)  # Number of villages
    total_pop = sum(pop)
    network_init = network_villiges(I_0, pop, m_BA, n_connect_villages)
    print('Number of villages =', n_villages)
    print('Total population of the villages',total_pop)
else:
    network_init = basic_networks(Network_type, I_0, int(N_init), m_BA)

N = nx.Graph.number_of_nodes(network_init)
N_edges = nx.Graph.number_of_edges(network_init)
contact_rate = N_edges*2/N
print('Nodes created in the end =', N)
print('Edges created in the end =', N_edges)
print('Average contact rate r =', contact_rate)
# R_0 (basic reproductive number): the average number of secondary infections generated by a single infected individual introduced into a susceptible population
R_0 = contact_rate*beta_mu/(gamma+mortality) # contact rate * average weighted infection rate * average removing period
print('R_0 = ',R_0)

# Check whether the network is fully connected
print('Number of unconnected ppl:', N - len(list(nx.connected_components(network_init))[0]), ' - Just checking if the network is legit')

if init_net == True:
    # Plot the initial network
    plt.figure(0)
    states= nx.get_node_attributes(network_init, 'state') 
    color=[colors[states[i]] for i in range(N)]
    nx.draw(network_init, node_color = color, with_labels=True, node_size=100)
    plt.show()
else:
    pass


if vaccination == True:
    beta_mu = beta_mu/3
    mu_r = mu_r - 6
    r_fraction = 1 - (1-r_fraction)/5


# Start assigning attributes
network_init, LT_dist, IB_dist = normal_dist(network_init, N, r_fraction,
                                        beta_mu, beta_sigma, mu_r, sigma_r, mu_m, sigma_m, mu_l, sigma_l, mu_ib, sigma_ib, mu_h, sigma_h, mu_ri, sigma_ri)
if latent_incub_plot == True:
    # Plotting the latent and incubation periods
    plt.figure(1)
    plt.hist(LT_dist, bins=100, label='Latent period')
    plt.hist([float(i) for i in IB_dist], bins=100, label='Incubation period')
    plt.legend()
    plt.show()
else:
    pass
print('day_LT mean = ', sum(LT_dist)/N)
print('day_IB mean = ', sum([float(i) for i in IB_dist])/N)


# Making sure every infectious node with the symptoms shown already by assigning their infection length higher than the incubation period
for i in network_init.nodes:
    if network_init.nodes[i]['state'] == 'I':
        print('Initially infected ppl:',i)
        network_init.nodes[i]['Iday'] = network_init.nodes[i]['dayIB']


# Randomizing the node labels to make the neighbor distribution accross the node labels more even (more neighbours for the initial nodes in BA)
label_list = list(range(N))
random.shuffle(label_list)
random_mapping = dict(zip(network_init, label_list))
network_random = nx.relabel_nodes(network_init, random_mapping, copy=True)
H = nx.Graph()
H.add_nodes_from(sorted(network_random.nodes(data=True)))
H.add_edges_from(network_random.edges(data=True))


# Convert into igragh for successfully saving and reading the nodes
ig_net = ig.Graph.from_networkx(H)
ig_net.write_gml("testnetwork.gml")

t_stop = timeit.default_timer()
print("time =",(t_stop-t_start)/60, 'min')
